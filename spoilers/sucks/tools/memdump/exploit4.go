package main

import (
	"fmt"
	"github.com/tarm/serial"
	"log"
	"os"
	"time"
)

func main() {
	log.SetFlags(log.LstdFlags | log.Lmicroseconds)
	log.Printf("Starting")

	c := &serial.Config{Name: os.Args[1], Baud: 19200}
	s, err := serial.OpenPort(c)
	if err != nil {
		panic(err)
	}

	payload := make([]byte, 1024)

	for i := 0; i < 512; i++ {
		payload[i*2] = 0x02
		payload[(i*2)+1] = 0xBF
	}

	code := []byte{0x21, 0, 0, 0x7e, 0xcd, 0x10, 0xbf, 0x23, 0x7c, 0xb5, 0xc2, 0x05, 0xbf, 0xcf, 0xf5, 0x0f, 0x0f, 0x0f, 0x0f, 0xcd, 0x19, 0xbf, 0xf1, 0xe6, 0x0f, 0xfe, 0x0a, 0xde, 0x2f, 0x27, 0xc3, 0x23, 0xbf, 0xf5, 0xdb, 0x09, 0x0f, 0xd2, 0x24, 0xbf, 0xf1, 0xd3, 0x08, 0xc9}

	for i, _ := range code {
		payload[2+i] = code[i]
	}

	payload[0] = 0
	payload[1] = 0

	ch := make(chan byte)

	go read(s, ch)

	cr := []byte("\r")
	_, err = s.Write(cr)
	if err != nil {
		panic(err)
	}

	<-ch

	s.Write(payload)
	_, err = s.Write(cr)
	if err != nil {
		panic(err)
	}

	for {
		time.Sleep(time.Second)
	}
}

func read(s *serial.Port, c chan byte) {
	buf := make([]byte, 64)
	for {
		n, err := s.Read(buf)
		if err != nil {
			log.Printf("Serial read error: %v", err)
			close(c)
			os.Exit(1)
		}
		fmt.Printf("%s", buf[:n])
		for _, b := range buf[:n] {
			if b == ':' {
				c <- 1
			}
		}
	}
}
